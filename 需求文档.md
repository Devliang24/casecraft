好的，遵照您的要求，我将结合我们讨论的所有细节（包括MVP范围、增量生成、并发处理、详细架构等），为您输出一份**最终版的、完整的、可以直接用于指导开发**的功能需求文档 (FRD)。

这份文档详细、清晰，并考虑了项目的初始版本（MVP）和未来的发展方向。

---

## **功能需求文档 (FRD) - CaseCraft**

**项目名称**: CaseCraft
**文档版本**: 1.0 (MVP)
**日期**: 2024-05-24
**作者**: [你的名字/团队名]

### **1. 简介**

#### **1.1 项目目标**
CaseCraft是一个命令行（CLI）工具，旨在通过自动化流程提升API测试的效率和质量。它能够解析标准的API文档（如OpenAPI/Swagger），并利用大型语言模型（LLM）的智能，生成**结构化的测试用例数据（以JSON格式）**。这些生成的JSON文件可以作为数据源，驱动各种自动化测试框架（如HttpRunner, Pytest, Jest等）的运行。

#### **1.2 目标用户**
*   **主要用户**: QA（质量保证）工程师、自动化测试工程师
*   **次要用户**: 后端开发工程师、DevOps工程师

#### **1.3 解决的核心问题**
*   **效率低下**: 手动编写API测试用例耗时、重复且枯燥。
*   **覆盖不足**: 手动编写的用例容易遗漏负向场景和边界值测试。
*   **维护困难**: 当API文档发生变更时，手动同步和维护大量的测试用例成本高昂。

### **2. 整体功能与范围**

#### **2.1 MVP版本核心范围**
本项目的初始版本（MVP）将专注于实现核心的“文档 -> LLM -> 结构化JSON”流程。输出格式**仅支持JSON**，以便快速验证核心价值并为后续功能迭代打下坚实基础。

#### **2.2 未来规划 (Post-MVP)**
*   **FR-EXT-01**: 支持直接导出为可执行的测试代码，如`pytest`和`jest`。
*   **FR-EXT-02**: 支持导出为`Postman Collection`格式，方便手动调试和探索。
*   **FR-EXT-03**: 增强交互模式，提供更丰富的终端UI体验。

### **3. 详细功能需求 (Functional Requirements)**

| 编号 | 功能模块 | 需求描述 | 验收标准 | 优先级 (MVP) |
| :--- | :--- | :--- | :--- | :--- |
| **FR-1** | **配置管理** | 用户能够安全、便捷地管理工具配置，特别是敏感信息。 | | **高** |
| FR-1.1 | 初始化配置 | 提供`casecraft init`命令。 | 1. 执行命令后，在用户主目录下的`.casecraft/`中创建`config.yaml`文件。<br>2. 配置文件包含API密钥、默认模型等占位符。 | 高 |
| FR-1.2 | 配置加载 | 程序能灵活加载配置。 | 1. 程序启动时，按“命令行参数 > 环境变量 > 配置文件”的优先级加载配置。<br>2. API密钥等敏感信息绝不能在日志中明文显示。 | 高 |
| **FR-2** | **API文档处理** | 工具能准确解析和理解标准的API文档。 | | **高** |
| FR-2.1 | 多源支持 | 支持从网络URL或本地文件系统加载API文档。 | 1. `casecraft generate https://...`能正常工作。<br>2. `casecraft generate ./api.yaml`能正常工作。 | 高 |
| FR-2.2 | 格式兼容性 | 支持主流的API规范和格式。 | 1. 能成功解析OpenAPI 3.0的JSON和YAML文件。<br>2. 能成功解析Swagger 2.0的JSON和YAML文件。 | 高 |
| FR-2.3 | 接口过滤 | 用户能精确指定要处理的API接口子集。 | 1. `--include-tag pet`只处理带`pet`标签的接口。<br>2. `--exclude-tag store`排除带`store`标签的接口。<br>3. `--include-path "/users/*"`支持通配符路径匹配。 | 高 |
| **FR-3** | **核心用例生成** | 工具能利用LLM智能生成全面、高质量的测试用例数据。 | | **高** |
| FR-3.1 | 智能生成 | 对每个选定的API接口，通过一次LLM调用生成其所有测试用例。 | 1. LLM的输入Prompt必须包含完整的API定义和明确的指令。<br>2. LLM的输出必须是一个结构化的JSON数组。 | 高 |
| FR-3.2 | 用例多样性 | 生成的用例需覆盖多种测试场景。 | 1. 至少包含一个成功的正向用例。<br>2. 至少包含三个不同类型的负向用例（如：缺少必填项、类型错误、格式错误）。<br>3. 如果API定义了数值或长度限制，必须包含边界值用例。 | 高 |
| FR-3.3 | 增量生成 | 工具能识别API变更，避免重复工作。 | 1. 首次运行后，在项目目录下生成`.casecraft_state.json`文件。<br>2. 再次运行时，对于定义未变更的接口，应在日志中提示“Skipping”并且不调用LLM。<br>3. 对于新增或变更的接口，应正常生成用例。 | 高 |
| FR-3.4 | 强制刷新 | 用户可以强制重新生成。 | 1. 使用`--force`参数时，即使接口未变更，也应重新调用LLM生成用例。 | 中 |
| **FR-4** | **输出与组织** | 生成的测试用例数据以清晰、可用的方式存储。 | | **高** |
| FR-4.1 | **JSON输出格式** | **MVP版本唯一的输出格式是JSON。** | 1. 每个API接口生成一个独立的`.json`文件。<br>2. 文件内容是一个JSON数组，每个元素是一个符合预定义Schema的测试用例对象。 | **高** |
| FR-4.2 | 目录组织 | 用户可以控制输出文件的目录结构。 | 1. 默认情况下，所有JSON文件平铺在输出目录中。<br>2. 使用`--organize-by tag`时，文件会根据API的第一个tag被放入对应的子目录中。 | 中 |
| **FR-5** | **执行与可靠性** | 工具在执行过程中应表现出高性能和高鲁棒性。 | | **高** |
| FR-5.1 | 并发处理 | 工具能并行处理多个API接口以缩短总耗时。 | 1. 用户可以通过`--workers N`参数指定并发线程数。<br>2. 当有多个接口需要处理时，程序的总耗时应显著低于串行执行。 | 高 |
| FR-5.2 | 速率限制处理 | 工具能优雅地应对LLM服务的速率限制。 | 1. 当收到HTTP 429错误时，程序不应崩溃。<br>2. 程序应自动等待一段时间后重试请求，并有最大重试次数限制。 | 高 |
| FR-5.3 | 演练模式 (Dry Run) | 用户可以在不产生费用的情况下预览操作。 | 1. 使用`--dry-run`参数时，程序不应发起任何LLM API调用。<br>2. 终端应清晰地打印出将要处理（新增/变更）和跳过（未变更）的接口列表。 | 高 |

### **4. 技术实现规范 (Technical Implementation Specifications)**

#### **4.1 技术选型**

| 组件 | 推荐技术 | 备注 |
| :--- | :--- | :--- |
| 编程语言 | Python 3.8+ | 丰富的生态系统，适合CLI工具开发 |
| CLI框架 | Click | 功能完善，文档清晰，支持复杂命令结构 |
| HTTP客户端 | httpx | 支持同步/异步，现代化设计 |
| YAML解析 | PyYAML | 标准YAML库 |
| JSON Schema验证 | jsonschema | OpenAPI文档验证 |
| 并发模型 | asyncio + aiofiles | 异步I/O，提升网络请求性能 |
| 配置管理 | pydantic + PyYAML | 类型安全的配置解析 |
| 日志 | structlog | 结构化日志，便于调试 |

#### **4.2 JSON输出Schema定义**

每个测试用例JSON对象必须符合以下结构：

```json
{
  "name": "string - 测试用例名称（如：'创建用户_正向_有效数据'）",
  "description": "string - 测试用例详细描述",
  "method": "string - HTTP方法（GET/POST/PUT/DELETE等）",
  "path": "string - API路径（如：'/users/{id}'）",
  "headers": "object - 请求头键值对",
  "path_params": "object - 路径参数（如：{'id': 123}）",
  "query_params": "object - 查询参数",
  "body": "object|null - 请求体数据",
  "expected_status": "number - 期望HTTP状态码",
  "expected_response_schema": "object - 期望响应结构的JSON Schema",
  "test_type": "enum - 测试类型：positive|negative|boundary",
  "tags": "array - 测试标签列表",
  "metadata": {
    "generated_at": "string - ISO时间戳",
    "api_version": "string - API版本",
    "llm_model": "string - 使用的LLM模型"
  }
}
```

#### **4.3 LLM集成规范**

```yaml
支持的LLM提供商:
  - OpenAI: GPT-3.5-turbo, GPT-4
  - Anthropic: Claude-3-haiku, Claude-3-sonnet
  - 本地模型: 通过OpenAI兼容API

Prompt模板结构:
  - 系统提示: 定义测试用例生成规则
  - API上下文: 完整的OpenAPI定义
  - 输出格式: JSON Schema约束
  - 示例: 1-2个标准测试用例示例

输出解析:
  - JSON验证: 严格按照Schema验证
  - 错误重试: 最多3次重试机制
  - 降级策略: 单个用例失败不影响整体流程
```

#### **4.4 状态文件结构**

`.casecraft_state.json` 格式定义：

```json
{
  "version": "1.0",
  "config": {
    "api_source": "URL或文件路径",
    "last_modified": "ISO时间戳",
    "source_hash": "API文档内容的MD5哈希"
  },
  "endpoints": {
    "GET:/users": {
      "definition_hash": "单个端点定义的哈希值",
      "last_generated": "ISO时间戳",
      "test_cases_count": 5,
      "output_file": "生成的JSON文件路径"
    }
  },
  "statistics": {
    "total_endpoints": 10,
    "generated_count": 8,
    "skipped_count": 2,
    "last_run_duration": "执行时长（秒）"
  }
}
```

#### **4.5 错误处理和日志规范**

```yaml
错误分类和处理:
  ConfigError: 配置文件错误，提供修复建议
  ParseError: API文档解析失败，指出具体位置
  LLMError: LLM调用异常，包含重试逻辑
  NetworkError: 网络连接问题，支持离线模式
  ValidationError: 输出验证失败，记录详细信息

日志级别使用:
  DEBUG: 详细的执行流程和数据
  INFO: 关键操作状态和进度
  WARN: 非致命错误和性能提醒
  ERROR: 致命错误和异常情况

重试机制:
  LLM API调用: 指数退避，最多3次
  网络请求: 固定间隔，最多5次
  文件I/O: 立即重试，最多2次
```

#### **4.6 性能基准和限制**

```yaml
默认配置:
  并发Worker数: min(32, CPU核心数 * 4)
  单次请求超时: 30秒
  LLM调用超时: 60秒
  内存使用限制: 512MB

性能目标:
  100个API端点: 完成时间 < 5分钟
  并发效率: 网络I/O利用率 > 80%
  内存占用: 峰值 < 256MB（不含LLM响应缓存）

缓存策略:
  API文档: 30分钟内存缓存
  LLM响应: 可选的磁盘缓存（开发调试用）
  配置文件: 启动时加载，运行时不重新读取
```

### **5. 非功能性需求 (Non-Functional Requirements)**

| 编号 | 类别 | 需求描述 |
| :--- | :--- | :--- |
| NFR-1 | **性能** | 瓶颈应主要在LLM API的网络延迟，而非工具本身的计算。在并发处理时，应能有效利用网络I/O。 |
| NFR-2 | **可用性** | CLI的命令和参数设计应符合Unix哲学，直观易懂。`--help`信息必须清晰、完整。错误消息应提供上下文和解决方案建议。 |
| NFR-3 | **可靠性** | 程序必须能健壮地处理各种预期内外的错误，包括：无效的API文档、网络连接中断、LLM返回非JSON或结构错误的响应等，并提供有意义的日志。 |
| NFR-4 | **可扩展性** | 系统架构应采用模块化设计（如“服务”模式），方便未来轻松地添加新的输出格式化器（如`PytestFormatter`），而无需改动核心引擎。 |
| NFR-5 | **安全性** | 用户的API密钥等敏感信息必须安全存储在用户目录下的配置文件中，绝不能被硬编码、记录到日志或包含在状态文件中。 |
| NFR-6 | **文档** | 项目必须提供一份高质量的`README.md`，内容包括：项目简介、特性列表、安装指南、快速上手（包含`init`和`generate`命令的完整示例）、配置说明和贡献指南。 |
| NFR-7 | **可测试性** | 核心逻辑（如API解析、状态管理）应与外部服务（LLM API、文件系统）解耦，方便进行单元测试。 |
| NFR-8 | **安装分发** | 支持多种安装方式：pip包、预编译二进制文件、Docker镜像。最小化外部依赖，支持主流操作系统。 |
| NFR-9 | **版本兼容** | Python 3.8+兼容，向后兼容的配置文件格式，清晰的API版本策略。 |

### **6. 测试策略 (Testing Strategy)**

#### **6.1 测试覆盖范围**

| 测试类型 | 覆盖率目标 | 关键测试点 |
| :--- | :--- | :--- |
| 单元测试 | > 90% | API解析器、配置管理、状态跟踪、输出格式化 |
| 集成测试 | > 80% | LLM API调用、文件I/O、命令行界面 |
| E2E测试 | 核心流程 | 完整的generate命令执行，错误场景处理 |
| 性能测试 | 基准验证 | 并发处理效率，内存使用稳定性 |

#### **6.2 测试数据和Mock**

```yaml
测试API文档:
  - 标准Petstore示例（OpenAPI 3.0）
  - 简化的内部API（Swagger 2.0）
  - 边界情况：大型文档、复杂嵌套结构

LLM Mock策略:
  - 开发环境：使用预定义响应文件
  - CI/CD：完全Mock，确保测试稳定性
  - 集成测试：真实API调用（限量）

错误场景覆盖:
  - 无效的API文档格式
  - LLM服务不可用
  - 网络连接中断
  - 磁盘空间不足
  - 权限不足
```
